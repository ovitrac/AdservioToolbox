# Cheat Sheet — Level 2: Workflows

## Eco Mode Workflow

Eco mode replaces Claude's sequential file browsing with deterministic structural
retrieval and persistent cross-file reasoning via 14 `memory_*` MCP tools.

### Enable/Disable

```bash
# In-session (Claude Code slash command)
/eco on                          # rm .claude/eco/.disabled
/eco off                         # touch .claude/eco/.disabled
/eco status                      # show state + memory stats

# Shell (persistent, writes .adservio-toolbox.toml)
toolboxctl eco on
toolboxctl eco off

# Direct flag file (same mechanism as /eco, no deps)
rm -f .claude/eco/.disabled      # enable eco
touch .claude/eco/.disabled      # disable eco
```

### What Eco Mode Changes

| Task | Without eco | With eco |
|------|-------------|----------|
| Explore a directory | `Read` 5-10 files sequentially | `memory_inspect` — one call |
| Find a function | `Glob` + `Read` + `Grep` | `memory_recall("FnName")` |
| Understand architecture | Read README + source files | `memory_recall("architecture")` |
| Read .docx/.pdf | Cannot (binary) | `memory_recall` — text extracted at sync |
| Remember across sessions | Cannot | `memory_propose` → `memory_recall` |

### Escalation Ladder

```
Level 1: memory_inspect     ← structural overview (one call, ~600 tokens)
Level 2: memory_recall      ← selective content retrieval (FTS5)
Level 3: memory_loop        ← iterative refinement (bounded)
Level 4: Native Read/View   ← last resort (editing, line-level precision)
```

Rule: do not skip levels. Narrow the query before falling back to native Read.

## memctl Workflows

### Ingest and Recall Cycle

```bash
# Initialize workspace (once per project)
memctl init

# Ingest files and recall relevant context in one shot
memctl push "authentication patterns" --source src/auth/

# Store LLM output as a note (pipe from stdin)
echo "The auth module uses JWT with RS256" | memctl pull --title "auth architecture"

# Search memories (FTS5)
memctl search "authentication"
memctl search --tier ltm "architecture decisions"
```

### Memory Tiers

| Tier | Name | Lifespan | Use Case |
|------|------|----------|----------|
| `stm` | Short-term | Session | Current task context |
| `mtm` | Medium-term | Days | Project patterns |
| `ltm` | Long-term | Persistent | Architecture decisions |

### Memory Hygiene

```bash
# View store statistics
memctl stats

# Show a specific item
memctl show <id>

# Export for backup (JSONL)
memctl export > memories.jsonl

# Import from backup
memctl import < memories.jsonl

# Rebuild FTS index (e.g. after changing tokenizer)
memctl reindex --fts-tokenizer en
```

## CloakMCP Workflows

### Sanitize Before Sharing

```bash
# Scan a file for secrets (writes audit log, no modifications)
cloak scan --policy .cloak/policy.yaml --input src/config.py

# Guard stdin (exit 1 if secrets detected)
cat src/config.py | cloak guard --policy .cloak/policy.yaml

# Pack a directory (reversible, vaulted)
cloak pack --policy .cloak/policy.yaml --dir src/

# Pack a single file
cloak pack-file --policy .cloak/policy.yaml --file src/config.py

# Restore originals
cloak unpack --dir src/
cloak unpack-file --file src/config.py

# Incremental re-pack (only new/changed files)
cloak repack --policy .cloak/policy.yaml --dir src/

# Verify no residual tags after unpack
cloak verify --dir src/
```

### Policy Configuration

```yaml
# .cloak/policy.yaml
version: 1
detection:
  - id: api_keys
    type: regex
    pattern: "sk-[a-zA-Z0-9_-]{20,}"
    action: redact
    severity: critical
  - id: aws_access_key
    type: regex
    pattern: "AKIA[0-9A-Z]{16}"
    action: redact
    severity: critical
  - id: high_entropy
    type: entropy
    min_entropy: 4.0
    min_length: 20
    action: redact
    severity: medium
```

### Policy Profiles

| Profile | Rules | Coverage |
|---------|-------|----------|
| Default (`mcp_policy.yaml`) | 10 | AWS, GCP, SSH, PEM, JWT, email, IP, URL, entropy |
| Enterprise (`mcp_policy_enterprise.yaml`) | 26 | + GitHub, GitLab, Slack, Stripe, npm, Azure, PKCS#8 |

### Claude Code Hooks (Automatic Mode)

```bash
# Install hooks (once per project, scripts bundled in PyPI wheel)
bash "$(cloak scripts-path)/install_claude.sh"                       # secrets-only profile (5 hooks)
bash "$(cloak scripts-path)/install_claude.sh" --profile hardened     # + Bash safety guard (6 hooks)
bash "$(cloak scripts-path)/install_claude.sh" --dry-run              # preview without changes

# Uninstall hooks
bash "$(cloak scripts-path)/install_claude.sh" --uninstall            # remove all hooks
bash "$(cloak scripts-path)/install_claude.sh" --uninstall --dry-run  # preview uninstall
```

Session lifecycle (fully automatic):

| Event | When | What Happens |
|-------|------|-------------|
| SessionStart | `claude` starts | `cloak pack` — secrets → TAG-xxx |
| UserPromptSubmit | Every prompt | Warns if prompt contains raw secrets |
| PreToolUse (Write/Edit) | Before file writes | Blocks writes containing secrets |
| PreToolUse (Bash) | Before shell commands | Blocks dangerous commands (hardened only) |
| PostToolUse | After Write/Edit/Bash | Audit log to `.cloak-session-audit.jsonl` |
| SessionEnd | `claude` exits | `cloak unpack` — restores secrets, verifies integrity |

### Recovery

If a session exits abnormally (crash, kill) and files remain packed:

```bash
cloak recover --dir .       # restore packed files from vault
cloak verify --dir .        # confirm no residual TAG-xxx tags
```

## Safe RAG Loop

The complete governance loop combining CloakMCP + memctl:

```
1. SessionStart hook            → cloak pack (automatic, secrets → TAG-xxx)
2. Claude Code works            → sees only safe tagged content
3. memctl push/pull             → stores sanitized context in memory
4. SessionEnd hook              → cloak unpack (automatic, TAG-xxx → secrets)
5. memctl search (next session) → filtered context recalled
```

### Key Invariants

- Nothing unsafe leaves the machine (CloakMCP hooks enforce automatically)
- Nothing unsafe becomes project memory (memctl stores tagged content)
- The loop is fully reversible and auditable
- Same secret = same TAG everywhere (deterministic HMAC-SHA256)

## Global vs Per-Project Wiring

The toolbox operates at two scopes:

### Global (`~/.claude/`) — `toolboxctl install --global`

| What | File | Purpose |
|------|------|---------|
| CloakMCP hooks | `~/.claude/settings.json` | Secret protection in every session |
| Bash permissions | `~/.claude/settings.local.json` | `Bash(cloak *)`, `Bash(memctl *)` |
| Behavioral rules | `~/.claude/CLAUDE.md` | CloakMCP tag handling instructions |

Global wiring fires automatically in every Claude Code session, regardless of project.

### Per-project (`.claude/`) — `toolboxctl init`

| What | File | Purpose |
|------|------|---------|
| Slash commands | `.claude/commands/*.md` | `/cheat`, `/tldr`, `/eco`, `/why`, `/how` |
| MCP servers | `.claude/settings.json` | memctl + CloakMCP MCP server registrations |
| Eco hooks | `.claude/settings.local.json` | Token-efficient retrieval (if eco installed) |
| Config | `.adservio-toolbox.toml` | Project-specific settings |

### Diagnostic

```bash
toolboxctl doctor                # check global + local state
toolboxctl status                # project-level status only
```

Doctor checks: Python, pipx, Claude Code, memctl, CloakMCP, PATH, global hooks, permissions, CLAUDE.md block.

Exit codes: 0 = all green, 1 = warnings, 2 = critical missing.

## Config Precedence

When a value can come from multiple sources:

```
CLI flags          (highest)
  ↓
Environment vars
  ↓
.adservio-toolbox.toml
  ↓
Compiled defaults  (lowest)
```

### Injecting Config into Shell

```bash
# Source all config as env vars
eval "$(toolboxctl env)"

# Or inspect as JSON
toolboxctl env --json
```
