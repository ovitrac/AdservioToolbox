# Cheat Sheet — Level 2: Workflows

## Eco Mode Workflow

Eco mode replaces Claude's sequential file browsing with deterministic structural
retrieval and persistent cross-file reasoning via 14 `memory_*` MCP tools.

### Enable/Disable

```bash
# In-session (Claude Code slash command)
/eco on                          # rm .claude/eco/.disabled
/eco off                         # touch .claude/eco/.disabled
/eco status                      # show state + memory stats

# Shell (persistent, writes .adservio-toolbox.toml)
toolboxctl eco on
toolboxctl eco off

# Direct flag file (same mechanism as /eco, no deps)
rm -f .claude/eco/.disabled      # enable eco
touch .claude/eco/.disabled      # disable eco
```

### What Eco Mode Changes

| Task | Without eco | With eco |
|------|-------------|----------|
| Explore a directory | `Read` 5-10 files sequentially | `memory_inspect` — one call |
| Find a function | `Glob` + `Read` + `Grep` | `memory_recall("FnName")` |
| Understand architecture | Read README + source files | `memory_recall("architecture")` |
| Read .docx/.pdf | Cannot (binary) | `memory_recall` — text extracted at sync |
| Remember across sessions | Cannot | `memory_propose` → `memory_recall` |

### Escalation Ladder

```
Level 1: memory_inspect     ← structural overview (one call, ~600 tokens)
Level 2: memory_recall      ← selective content retrieval (FTS5)
Level 3: memory_loop        ← iterative refinement (bounded)
Level 4: Native Read/View   ← last resort (editing, line-level precision)
```

Rule: do not skip levels. Narrow the query before falling back to native Read.

## memctl Workflows

### Ingest and Recall Cycle

```bash
# Initialize workspace (once per project)
memctl init

# Ingest files and recall relevant context in one shot
memctl push "authentication patterns" --source src/auth/

# Store LLM output as a note (pipe from stdin)
echo "The auth module uses JWT with RS256" | memctl pull --title "auth architecture"

# Search memories (FTS5)
memctl search "authentication"
memctl search --tier ltm "architecture decisions"
```

### Memory Tiers

| Tier | Name | Lifespan | Use Case |
|------|------|----------|----------|
| `stm` | Short-term | Session | Current task context |
| `mtm` | Medium-term | Days | Project patterns |
| `ltm` | Long-term | Persistent | Architecture decisions |

### Memory Hygiene

```bash
# View store statistics
memctl stats

# Show a specific item
memctl show <id>

# Export for backup (JSONL)
memctl export > memories.jsonl

# Import from backup
memctl import < memories.jsonl

# Rebuild FTS index (e.g. after changing tokenizer)
memctl reindex --fts-tokenizer en
```

## CloakMCP Workflows

### Sanitize Before Sharing

```bash
# Scan a file for secrets (writes audit log, no modifications)
cloak scan --policy .cloak/policy.yaml --input src/config.py

# Guard stdin (exit 1 if secrets detected)
cat src/config.py | cloak guard --policy .cloak/policy.yaml

# Pack a directory (reversible, vaulted)
cloak pack --policy .cloak/policy.yaml --dir src/

# Pack a single file
cloak pack-file --policy .cloak/policy.yaml --file src/config.py

# Restore originals
cloak unpack --dir src/
cloak unpack-file --file src/config.py

# Incremental re-pack (only new/changed files)
cloak repack --policy .cloak/policy.yaml --dir src/

# Verify no residual tags after unpack
cloak verify --dir src/
```

### Policy Configuration

```yaml
# .cloak/policy.yaml
version: 1
detection:
  - id: api_keys
    type: regex
    pattern: "sk-[a-zA-Z0-9_-]{20,}"
    action: redact
    severity: critical
  - id: aws_access_key
    type: regex
    pattern: "AKIA[0-9A-Z]{16}"
    action: redact
    severity: critical
  - id: high_entropy
    type: entropy
    min_entropy: 4.0
    min_length: 20
    action: redact
    severity: medium
```

### Policy Profiles

| Profile | Rules | Coverage |
|---------|-------|----------|
| Default (`mcp_policy.yaml`) | 10 | AWS, GCP, SSH, PEM, JWT, email, IP, URL, entropy |
| Enterprise (`mcp_policy_enterprise.yaml`) | 26 | + GitHub, GitLab, Slack, Stripe, npm, Azure, PKCS#8 |

### CloakMCP Security Profiles

CloakMCP security has **two independent dimensions** — combine any hook profile with any policy profile:

| Dimension | Options | Controls |
|-----------|---------|----------|
| **Hook profile** | `secrets-only` (5 hooks) / `hardened` (7 hooks) | What Claude is prevented from doing |
| **Policy profile** | `default` (10 rules) / `enterprise` (26 rules) / custom | What counts as a secret |

#### Which hook profile?

| Profile | Hooks | Best for |
|---------|-------|----------|
| **secrets-only** (default) | 5 | Personal projects, trusted codebase, fast iteration |
| **hardened** | 7 | Client projects, shared repos, CI/CD, compliance-sensitive work |

**What hardened adds** over secrets-only:

| Hook | Event | What it blocks |
|------|-------|----------------|
| `cloak-safety-guard.sh` | PreToolUse (Bash) | 13 dangerous patterns (see below) |
| `cloak-guard-read.sh` | PreToolUse (Read/Grep/Glob) | File reads outside the project tree |

**Bash safety guard — blocked commands** (13 patterns):

| Pattern | Why |
|---------|-----|
| `rm -rf /` | Recursive delete root |
| `sudo rm` | Privileged delete |
| `curl \| sh`, `curl \| bash` | Remote code execution |
| `wget \| sh`, `wget \| bash` | Remote code execution |
| `git push --force`, `git push -f` | Force push (destructive) |
| `git reset --hard` | Discard all changes |
| `git clean -f` | Remove untracked files |
| `chmod -R 777` | World-writable permissions |
| `dd ... of=/dev/` | Raw disk write |
| `mkfs` | Format filesystem |

#### Which policy profile?

| Profile | Rules | Best for |
|---------|-------|----------|
| **default** (`mcp_policy.yaml`) | 10 | Standard projects (AWS, GCP, SSH, PEM, JWT, email, IP, URL, entropy) |
| **enterprise** (`mcp_policy_enterprise.yaml`) | 26 | Client/regulated work (+ GitHub, GitLab, Slack, Stripe, npm, Azure, PKCS#8) |
| **custom** (your YAML) | N | Project-specific rules inheriting from default or enterprise |

#### Switching profiles

```bash
# Switch policy profile (what counts as a secret)
cloak policy use mcp_policy.yaml                    # default (10 rules)
cloak policy use mcp_policy_enterprise.yaml          # enterprise (26 rules)
cloak policy use /path/to/custom-policy.yaml         # custom

# Switch hook profile (what Claude is prevented from doing)
bash "$(cloak scripts-path)/install_claude.sh"                       # secrets-only (5 hooks)
bash "$(cloak scripts-path)/install_claude.sh" --profile hardened     # hardened (7 hooks)
```

#### Upgrading from secrets-only to hardened

```bash
# Re-run the installer with --profile hardened (idempotent, overwrites hooks)
bash "$(cloak scripts-path)/install_claude.sh" --profile hardened

# Verify: doctor shows 7 hooks
toolboxctl doctor
# → Global hooks ~/.claude/   ✓  CloakMCP hardened (7 hooks)
```

No uninstall needed first — the installer replaces the hook configuration in place.

### Claude Code Hooks (Automatic Mode)

```bash
# Install hooks (once per project, scripts bundled in PyPI wheel)
bash "$(cloak scripts-path)/install_claude.sh"                       # secrets-only hook profile (5 hooks)
bash "$(cloak scripts-path)/install_claude.sh" --profile hardened     # + Bash safety + read guard (7 hooks)
bash "$(cloak scripts-path)/install_claude.sh" --dry-run              # preview without changes

# Uninstall hooks
bash "$(cloak scripts-path)/install_claude.sh" --uninstall            # remove all hooks
bash "$(cloak scripts-path)/install_claude.sh" --uninstall --dry-run  # preview uninstall
```

Session lifecycle (fully automatic):

| Event | When | What Happens |
|-------|------|-------------|
| SessionStart | `claude` starts | `cloak pack` — secrets → TAG-xxx |
| UserPromptSubmit | Every prompt | Warns if prompt contains raw secrets |
| PreToolUse (Write/Edit) | Before file writes | Blocks writes containing secrets |
| PreToolUse (Bash) | Before shell commands | Blocks dangerous commands (hardened only) |
| PreToolUse (Read/Grep/Glob) | Before file reads | Blocks reads outside project tree (hardened only) |
| PostToolUse | After Write/Edit/Bash | Audit log to `.cloak-session-audit.jsonl` |
| SessionEnd | `claude` exits | `cloak unpack` — restores secrets, verifies integrity |

### Secret Recovery

If a session exits abnormally (crash, kill) and files remain packed with `TAG-xxxx`
placeholders, use `toolboxctl rescue` for guided recovery:

```bash
# Guided workflow (diagnose → report → confirm → recover → verify)
toolboxctl rescue               # diagnose and recover in cwd
toolboxctl rescue --dir ./proj  # target specific directory
toolboxctl rescue --dry-run     # preview without changes
toolboxctl rescue --force       # skip confirmation prompts

# Backup-based recovery
toolboxctl rescue --from-backup                  # list available backups
toolboxctl rescue --from-backup 20260224_143000  # restore from specific backup
```

Rescue wraps the underlying CloakMCP commands in a safe sequence:

| Scenario | What rescue does | Manual equivalent |
|----------|-----------------|-------------------|
| Stale session (crash/kill) | `cloak recover` then `cloak verify` | `cloak recover --dir . && cloak verify --dir .` |
| Residual TAG-xxxx tags | `cloak restore` then `cloak verify` | `cloak restore --dir . && cloak verify --dir .` |
| Both (critical) | recover → restore → verify | Run both commands in sequence |
| From backup | `cloak restore --from-backup` | `cloak restore --from-backup --backup-id ID --force --dir .` |

If rescue cannot fully resolve the issue, it reports remaining problems and
suggests manual inspection commands.

### Memory Advisory

"Memory loss" in practice means: wrong DB root, unmounted projects, stale scans,
broken FTS, or consolidation debt. The memory advisory diagnoses these without
mutations.

```bash
# Combined: secret recovery + memory health
toolboxctl rescue --with-memory

# Memory checks only (skip secret recovery)
toolboxctl rescue --memory-only

# JSON output (for CI / support tickets)
toolboxctl rescue --json --with-memory
toolboxctl rescue --memory-only --json
```

The advisory probes `memctl doctor` (10 structured checks, v0.18.0+), then
`memctl status/stats/consolidate --dry-run` for operational advice. Falls back
to status+stats when doctor is unavailable.

| Advice | Meaning | Fix |
|--------|---------|-----|
| Memory database not found | No `.memory/memory.db` in cwd | `memctl init` |
| Memory is empty | DB exists but zero items | `memctl push` or `/scan` |
| Eco mode not installed | Eco hooks not wired | `toolboxctl eco on` |
| FTS tokenizer mismatch | Index built with different tokenizer | `memctl reindex --dry-run` |
| Consolidation suggested | STM items ready for merge | `memctl consolidate --dry-run` |
| FTS5 not available | SQLite lacks FTS5 extension | Upgrade SQLite or rebuild Python |
| Database integrity failed | SQLite integrity_check error | Backup + `memctl init --force` |

Exit codes for `--memory-only`: `0` = healthy, `1` = issues found, `2` = memctl missing.

## Safe RAG Loop

The complete governance loop combining CloakMCP + memctl:

```
1. SessionStart hook            → cloak pack (automatic, secrets → TAG-xxx)
2. Claude Code works            → sees only safe tagged content
3. memctl push/pull             → stores sanitized context in memory
4. SessionEnd hook              → cloak unpack (automatic, TAG-xxx → secrets)
5. memctl search (next session) → filtered context recalled
```

### Key Invariants

- Nothing unsafe leaves the machine (CloakMCP hooks enforce automatically)
- Nothing unsafe becomes project memory (memctl stores tagged content)
- The loop is fully reversible and auditable
- Same secret = same TAG everywhere (deterministic HMAC-SHA256)

## Project Setup Lifecycle

`toolboxctl init` is the "git init" of Claude-Code-ready projects: idempotent, reversible, upgradable.

### What init creates

| Artifact | Path | Tracked | Purpose |
|----------|------|---------|---------|
| Slash commands | `.claude/commands/*.md` | yes | `/cheat`, `/tldr`, `/eco`, `/why`, `/how` |
| MCP servers | `.claude/settings.json` | yes | memctl + CloakMCP registrations |
| Permissions | `.claude/settings.local.json` | no | `Bash(cloak:*)`, `Bash(memctl:*)`, `Bash(toolboxctl:*)` |
| Config | `.adservio-toolbox.toml` | yes | Project-specific settings |
| CLAUDE.md block | `CLAUDE.md` | yes | Marker-based toolbox instructions |
| Manifest | `.toolbox/manifest.json` | yes | "This repo is initialized" marker |
| State | `.toolbox/state.json` | no | Reversible state for deinit |
| gitignore entries | `.gitignore` | yes | Excludes `settings.local.json`, `state.json` |

### Init is idempotent

```bash
toolboxctl init          # first run: creates everything
toolboxctl init          # second run: "already configured" for each item
toolboxctl init --force  # re-run: overwrites all files
```

### Deinit reverses init

```bash
toolboxctl deinit        # interactive confirmation
toolboxctl deinit --force  # skip confirmation
```

**Removed:** slash commands, MCP servers, permissions, config, CLAUDE.md block, manifest, state.

**Preserved:** `.memory/`, `.claude/hooks/`, `.claude/eco/`, user CLAUDE.md content outside markers.

### CLAUDE.md block injection

The toolbox injects a marker-delimited block into the project `CLAUDE.md`:

```markdown
<!-- ADSERVIO_TOOLBOX PROJECT BEGIN — managed by toolboxctl, do not edit manually -->
## Adservio Toolbox
- CloakMCP is active ...
<!-- ADSERVIO_TOOLBOX PROJECT END -->
```

- **File doesn't exist** -> creates it with block only
- **File exists, no markers** -> appends block at the end
- **File exists with markers** -> replaces between markers in-place

User content outside the markers is never touched.

### Auto-update

```bash
toolboxctl update               # upgrade all tools (pipx/pip auto-detected)
toolboxctl update --check       # show installed vs latest without upgrading
toolboxctl update --quiet       # minimal output (for launcher scripts)
```

After upgrading, if `.toolbox/manifest.json` exists, project templates (CLAUDE.md block, manifest version) are refreshed automatically.

### Relationship to playground.sh

`playground.sh` extends `init` with hooks:

```
toolboxctl init          → slash commands, MCP, permissions, config, CLAUDE.md, manifest
playground.sh            → init + CloakMCP hooks + memctl eco hooks + starter CLAUDE.md header
```

Use `toolboxctl init` for lightweight project setup. Use `playground.sh` for full hook-wired environments.

## CLAUDE.md Layer Doctrine

The toolbox enforces a strict separation between CLAUDE.md layers:

| Layer | Location | Role | Content |
|-------|----------|------|---------|
| **GLOBAL** | `~/.claude/CLAUDE.md` | Seatbelt | CloakMCP safety rules, pre-authorized CLIs, neutral eco sentence |
| **PROJECT** | `./CLAUDE.md` | Overlay | References GLOBAL for safety, neutral eco pointer, profile-specific addenda |
| **ECO.md** | `.claude/eco/ECO.md` | Activation docs | All memctl MCP/CLI workflow guidance (created by memctl, not toolboxctl) |

### Doctrine Rules

| Rule | Meaning |
|------|---------|
| GLOBAL = seatbelt | CloakMCP safety + plumbing. ONE neutral eco sentence. No memctl workflow guidance. |
| PROJECT = overlay | References GLOBAL for safety (never restates). ONE neutral eco pointer. |
| ECO.md = activation docs | All real memctl CLI/MCP guidance lives in `.claude/eco/ECO.md`. |
| No default memctl bias | memctl tools are never "recommended" by default in any CLAUDE.md block. |
| Playground = profile tag | Uses `--profile playground` in manifest. Same PROJECT markers. Not a third policy layer. |

### Profiles

```bash
toolboxctl init                       # minimal profile (default)
toolboxctl init --profile dev         # dev profile (+ .claude/PROJECT.md)
toolboxctl init --profile playground  # playground profile (+ CHALLENGE.md pointer)
```

| Profile | CLAUDE.md block | Extra artifacts |
|---------|----------------|-----------------|
| `minimal` | Base only (global ref + eco pointer) | — |
| `dev` | Base + `.claude/PROJECT.md` pointer | `.claude/PROJECT.md` (build/test/lint/format) |
| `playground` | Base + `CHALLENGE.md` pointer | — |

### Policy Lint

```bash
toolboxctl doctor                # includes policy lint checks (WARN)
toolboxctl doctor --strict       # lint warnings become errors (exit 2)
toolboxctl doctor --ci           # alias for --strict
```

| Check | What it detects | Default | Strict |
|-------|----------------|---------|--------|
| L1 | Legacy global markers (`ADSERVIO_TOOLBOX BEGIN`) | WARN | FAIL |
| L2 | memctl guidance in global block (`memory_recall`) | WARN | FAIL |
| L3 | CloakMCP rules restated in project block | WARN | FAIL |
| L4 | ECO.md referenced but `.claude/eco/ECO.md` missing | WARN | FAIL |

### Scoped Block Refresh

```bash
toolboxctl update --global       # refresh global CLAUDE.md block only
toolboxctl update --project      # refresh project CLAUDE.md block only (reads profile from manifest)
```

## Global vs Per-Project Wiring

The toolbox operates at two scopes:

### Global (`~/.claude/`) — `toolboxctl install --global`

| What | File | Purpose |
|------|------|---------|
| CloakMCP hooks | `~/.claude/settings.json` | Secret protection in every session |
| Bash permissions | `~/.claude/settings.local.json` | `Bash(cloak:*)`, `Bash(memctl:*)` |
| Behavioral rules | `~/.claude/CLAUDE.md` | CloakMCP safety seatbelt (doctrine: no memctl guidance) |

Global wiring fires automatically in every Claude Code session, regardless of project.

### Per-project (`.claude/`) — `toolboxctl init`

| What | File | Purpose |
|------|------|---------|
| Slash commands | `.claude/commands/*.md` | `/cheat`, `/tldr`, `/eco`, `/why`, `/how` |
| MCP servers | `.claude/settings.json` | memctl + CloakMCP MCP server registrations |
| Eco hooks | `.claude/settings.local.json` | Token-efficient retrieval (if eco installed) |
| Config | `.adservio-toolbox.toml` | Project-specific settings |

### Diagnostic

```bash
toolboxctl doctor                # check global + local state + policy lint
toolboxctl doctor --strict       # lint warnings become errors (exit 2)
toolboxctl status                # project-level status only
```

Doctor checks: Python, pipx, Claude Code, memctl, CloakMCP, PATH, global hooks, permissions, CLAUDE.md block, policy lint.

Exit codes: 0 = all green, 1 = warnings, 2 = critical missing.

### Per-Project Setup (Standalone Script)

For one-command per-project setup (init + hooks + starter CLAUDE.md):

```bash
# Setup in current directory
bash scripts/playground.sh

# Setup in specific directory
bash scripts/playground.sh --dir ~/projects/my-app

# Enterprise CloakMCP profile (26 rules)
bash scripts/playground.sh --dir ~/projects/my-app --hardened

# Init + CLAUDE.md only (no hooks)
bash scripts/playground.sh --skip-hooks

# Curl-able (no clone needed)
curl -fsSL https://raw.githubusercontent.com/ovitrac/AdservioToolbox/main/scripts/playground.sh \
  | bash -s -- --dir /path/to/project

# Remove wiring (preserves .memory/ and user config)
bash scripts/playground.sh --teardown --dir ~/projects/my-app
```

The script enforces correct hook ordering (CloakMCP first, memctl second) and
verifies the result. Run `--dry-run` to preview all actions before executing.

### Playground Contract

**Toolbox-owned files** (created by setup, removed by teardown):

| Path | Created by | Purpose |
|------|-----------|---------|
| `.adservio-toolbox.toml` | `toolboxctl init` | Project configuration |
| `.claude/commands/cheat.md` | `toolboxctl init` | `/cheat` slash command |
| `.claude/commands/tldr.md` | `toolboxctl init` | `/tldr` slash command |
| `.claude/commands/eco.md` | `toolboxctl init` | `/eco` slash command |
| `.claude/commands/why.md` | `toolboxctl init` | `/why` slash command |
| `.claude/commands/how.md` | `toolboxctl init` | `/how` slash command |
| `.claude/hooks/cloak-*.sh` | CloakMCP installer | Session boundary hooks |
| `.claude/settings.local.json` (hooks key) | CloakMCP installer | Hook registration |

**Teardown guarantees** (never touched by `--teardown`):

| Path | Reason |
|------|--------|
| `.memory/` | User knowledge — never deleted by toolbox |
| `.claude/settings.json` (MCP servers) | May contain non-toolbox entries |
| `.claude/settings.local.json` (non-hook keys) | User permissions preserved |
| `CLAUDE.md` (user content) | Teardown does not touch project CLAUDE.md |

**Hook ordering** (non-negotiable):

1. CloakMCP hooks **first** — replaces entire `hooks` key in `settings.local.json`
2. memctl eco hooks **second** — appends to `UserPromptSubmit`, preserving CloakMCP hooks

Reversing this order will silently overwrite memctl hooks.

**Hardened hook profile** (`--hardened`):

- Adds Bash safety guard hook (blocks 13 dangerous patterns — see "CloakMCP Security Profiles" above)
- Adds read guard hook (blocks file reads outside project tree)
- 7 hooks total vs 5 in secrets-only
- Uses enterprise policy (26 detection rules vs 10 in default)
- Same teardown path — no special cleanup needed

## Config Precedence

When a value can come from multiple sources:

```
CLI flags          (highest)
  ↓
Environment vars
  ↓
.adservio-toolbox.toml
  ↓
Compiled defaults  (lowest)
```

### Injecting Config into Shell

```bash
# Source all config as env vars
eval "$(toolboxctl env)"

# Or inspect as JSON
toolboxctl env --json
```
